type Position = Vec 3 Float 
type PositionHomo = Vec 4 Float 
type Normal = Vec 3 Float
type UV = Vec 2 Float
type Color = Vec 4 Float 
type ShadowCoord = Vec 4 Float 

homonize :: Vec 3 Float -> Vec 4 Float 
homonize v = V4 v%x v%y v%z 1 

unhomonize :: Vec 4 Float -> Vec 3 Float 
unhomonize v = V3 (v%x / v%w) (v%y / v%w) (v%z / v%w)

vec3 :: Float -> Vec 3 Float 
vec3 a = V3 a a a 

shadowMapSize :: Int 
shadowMapSize = 1024

-- | Transforms [-1 .. 1] range to [0 .. 1]
biasMatrix :: Mat 4 4 Float 
biasMatrix = M44F 
  (V4 0.5 0.0 0.0 0.0)
  (V4 0.0 0.5 0.0 0.0)
  (V4 0.0 0.0 0.5 0.0)
  (V4 0.5 0.5 0.5 1.0)

-- | Raster objects from view of directed light and save depth
makeShadowMap (depthMVP :: Mat 4 4 Float)
              (prims :: PrimitiveStream Triangle (Vec 3 Float, Vec 3 Float, Vec 2 Float))

    = imageFrame (emptyDepthImage 1, emptyColorImage (V4 1 1 1 1.0))
    `overlay`
      prims 
    & mapPrimitives (\(v, n, uv) -> let v' = depthMVP *. homonize v in (v', v'))
    & rasterizePrimitives (TriangleCtx CullBack PolygonFill NoOffset LastVertex) Smooth
    & mapFragments (\v -> v%zzzw)
    & accumulateWith (DepthOp Less True, ColorOp NoBlending (V4 True True True True))

-- | Final render of object using shadow map generated at previous pass
makeFrame (modelMat :: Mat 4 4 Float)
          (viewMat :: Mat 4 4 Float)
          (projMat :: Mat 4 4 Float)
          (texture :: Texture)
          (lightDirection :: Vec 3 Float)
          (shadowMap :: Texture)
          (depthMVP :: Mat 4 4 Float)
          (prims :: PrimitiveStream Triangle (Vec 3 Float, Vec 3 Float, Vec 2 Float))

    = imageFrame (emptyDepthImage 1, emptyColorImage (V4 0 0 0.4 1))
   `overlay`
      prims
    & mapPrimitives transform
    & rasterizePrimitives (TriangleCtx CullNone PolygonFill NoOffset LastVertex) (Smooth, Smooth, Smooth, Smooth)
    & mapFragments enlight
    & accumulateWith (DepthOp Less True, ColorOp NoBlending (V4 True True True True))
  where
    mv = modelMat .*. viewMat
    mvp = transpose $ mv .*. projMat -- loaded matricies are transposed
    viewmatInvT = inv mv -- double transpose eliminated

    transNormal :: Normal -> Normal
    transNormal = normalize . unhomonize . (viewmatInvT *.) . homonize

    transform :: (Position, Normal, UV) -> (PositionHomo, Position, Normal, UV, ShadowCoord)
    transform (p,n,uv) = (p', unhomonize pview, transNormal n, uv, shadowCoord)
      where p' = mvp *. homonize p
            pview = (transpose $ modelMat .*. viewMat) *. homonize p
            shadowCoord = (biasMatrix .*. depthMVP) *. homonize p

    enlight :: (Position, Normal, UV, ShadowCoord) -> Color
    enlight (vertPos, normal, uv, shadowCoord) = homonize colorLinear
      where 
        ambientColor = V3 0 0 0
        diffuseColor = texture2D (Sampler PointFilter MirroredRepeat texture) uv :: Vec 4 Float
        specColor = V3 1 1 1 
        shininess = 64.0

        lightDirView = unhomonize $ transpose viewMat *. homonize lightDirection
        lightDir = normalize $ lightDirView *! (-1)

        lambertian = max (lightDir `dot` normal) 0
        viewDir = normalize (vertPos *! (-1))
        halfDir = normalize $ lightDir + viewDir
        specAngle = max (halfDir `dot` normal) 0
        specular = if lambertian <= 0 then 0 else pow specAngle shininess

        colorLinear = ambientColor + (diffuseColor%xyz) *! lambertian + specColor *! specular


main :: Output
main = renderFrame $
  let shadowMap = Texture2D (V2 shadowMapSize shadowMapSize) . PrjImageColor $ makeShadowMap depthMVP objects
  in makeFrame (Uniform "modelMat") 
            (Uniform "viewMat")
            (Uniform "projMat")
            (Texture2DSlot "diffuseTexture")
            (Uniform "lightDir")
            shadowMap
            depthMVP
            objects
  where
    depthMVP = Uniform "depthMVP"
    objects = fetch_ "objects" (Attribute "position", Attribute "normal", Attribute "uv")